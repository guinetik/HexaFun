<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0-M16 from src/site/markdown/fluent.md
 | Rendered using Apache Maven Fluido Skin 2.0.0-M8
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0-M16" />
    <title>HexaFun – The Fluent DSL</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.0.0-M8.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.0.0-M8.min.js"></script>
<!-- Google Analytics 4 -->
                <script async src="https://www.googletagmanager.com/gtag/js?id=G-9J979FF4TK"></script>
                <script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){dataLayer.push(arguments);}
                    gtag('js', new Date());
                    gtag('config', 'G-9J979FF4TK');
                </script>
                <!-- SEO Meta Tags -->
                <meta name="description" content="HexaFun - A lightweight, functional approach to Hexagonal Architecture in Java. Fluent DSL for ports, adapters, and use cases with zero dependencies." />
                <meta name="keywords" content="hexagonal architecture, ports and adapters, java, clean architecture, domain driven design, ddd, functional programming, fluent api, use cases" />
                <meta name="author" content="guinetik" />

                <!-- Open Graph / Facebook -->
                <meta property="og:type" content="website" />
                <meta property="og:url" content="https://hexafun.guinetik.com/" />
                <meta property="og:title" content="HexaFun - Functional Patterns for Hexagonal Architecture" />
                <meta property="og:description" content="A lightweight, functional approach to Hexagonal Architecture in Java. Fluent DSL for ports, adapters, and use cases with zero dependencies." />
                <meta property="og:image" content="https://hexafun.guinetik.com/images/og-image.png" />

                <!-- Twitter/X Card -->
                <meta name="twitter:card" content="summary_large_image" />
                <meta name="twitter:site" content="@guinetik" />
                <meta name="twitter:creator" content="@guinetik" />
                <meta name="twitter:title" content="HexaFun - Hexagonal Architecture for Java" />
                <meta name="twitter:description" content="A lightweight, functional approach to Hexagonal Architecture in Java." />
                <meta name="twitter:image" content="https://hexafun.guinetik.com/images/og-image.png" />
                <meta name="twitter:image:alt" content="HexaFun logo and architecture diagram" />

                <!-- Threads/Instagram (uses OG tags above) -->
                <!-- Additional OG tags for broader compatibility -->
                <meta property="og:site_name" content="HexaFun" />
                <meta property="og:image:width" content="1200" />
                <meta property="og:image:height" content="630" />
                <meta property="og:image:type" content="image/png" />

                <!-- Favicon -->
                <link rel="icon" type="image/svg+xml" href="./images/favicon.svg" />
                <link rel="icon" type="image/png" sizes="32x32" href="./images/favicon-32x32.png" />
                <link rel="icon" type="image/png" sizes="16x16" href="./images/favicon-16x16.png" />
  
<!-- <!-- terminal-javadocs-injected [site] -->
<link rel="stylesheet" href="./terminal-styles/terminaljavadocs-site.min.css">
<script src="./terminal-styles/terminaljavadocs.min.js" defer></script>
</head>
  <body class="topBarEnabled">
    <header id="topbar" class="navbar navbar-fixed-top navbar-dark">
      <div class="navbar-inner">
            <div class="container">
              <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
              </a>
          <nav class="nav-collapse">
<a class="brand" href="index.html"><img src="./images/logo.svg" alt="HexaFun" />
</a>
            <ul class="nav">
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Overview <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="index.html">Introduction</a></li>
            <li><a href="tutorial.html">Hexagonal Architecture Tutorial</a></li>
            <li><a href="adapters.html">Adapters</a></li>
            <li><a>Fluent DSL</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="apidocs/index.html">Javadoc</a></li>
            <li><a href="source-xref.html">Source Code (XRef)</a></li>
            <li><a href="coverage.html">Code Coverage</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Project Information <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li class="dropdown-submenu">
<a href="project-info.html">Project Information</a>
              <ul class="dropdown-menu">
                  <li><a href="index.html">About</a></li>
                  <li><a href="summary.html">Summary</a></li>
                  <li><a href="modules.html">Project Modules</a></li>
                  <li><a href="licenses.html">Licenses</a></li>
              </ul>
            </li>
            <li class="dropdown-submenu">
<a href="project-reports.html">Project Reports</a>
              <ul class="dropdown-menu">
                  <li><a href="apidocs/index.html">Javadoc</a></li>
                  <li><a href="testapidocs/index.html">Test Javadoc</a></li>
              </ul>
            </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Links <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="./">GitHub</a></li>
            <li><a href="issues">Issues</a></li>
        </ul>
      </li>
            </ul>
          </nav>
          <div class="nav-collapse">
    <ul class="nav pull-right" style="border:none; margin-top: 7px"><li>
    <a href="https://twitter.com/guinetik" class="twitter-follow-button" data-show-count="true" data-align="right" data-size="large" data-show-screen-name="true" data-lang="en" data-dnt="true" >Follow guinetik</a>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    </li></ul>
          </div>
        </div>
      </div>
    </header>
    <div class="container container-top">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2025-12-16<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.0.1<span class="divider">|</span></li>
      <li><a href="index.html">HexaFun</a><span class="divider">/</span></li>
    <li class="active">The Fluent DSL</li>
          </ul>
        </div>
      </header>
        <main id="bodyColumn">
<section>
<h1>The Fluent DSL</h1>
<p>HexaFun provides a fluent DSL for composing use cases in a declarative, type-safe manner.
This page covers the design principles and usage patterns of the DSL.</p><hr /><section>
<h2>Design Principles</h2>
<p>The DSL was designed around four key principles:</p>
<ol style="list-style-type: decimal;">

<li><strong>Type Safety</strong>: Compile-time verification of input/output types</li>
<li><strong>Clarity</strong>: Method names that express intent (<code>validate</code>, <code>handle</code>)</li>
<li><strong>Minimal Ceremony</strong>: No boilerplate connectors or explicit closures</li>
<li><strong>Composability</strong>: Chain validators naturally</li>
</ol><hr /></section><section>
<h2>Type-Safe Keys</h2>
<p>Use cases are identified by <code>UseCaseKey&lt;I, O&gt;</code> which carries type information at compile time:</p>

<div class="verbatim">
<pre><code class="language-java">// Define keys with their input and output types
public interface TaskUseCases {
    UseCaseKey&lt;CreateInput, Result&lt;Task&gt;&gt; CREATE = UseCaseKey.of(&quot;create&quot;);
    UseCaseKey&lt;UpdateInput, Result&lt;Task&gt;&gt; UPDATE = UseCaseKey.of(&quot;update&quot;);
    UseCaseKey&lt;String, Result&lt;Task&gt;&gt; DELETE = UseCaseKey.of(&quot;delete&quot;);
    UseCaseKey&lt;Void, List&lt;Task&gt;&gt; LIST = UseCaseKey.of(&quot;list&quot;);
}
</code></pre></div>
<p>This approach provides:</p>
<table class="table table-striped">
<thead>
<tr class="a">
<th>Benefit</th>
<th>How</th></tr></thead><tbody>
<tr class="b">
<td>Compile-time safety</td>
<td>Wrong input type won't compile</td></tr>
<tr class="a">
<td>Single source of truth</td>
<td>All signatures in one interface</td></tr>
<tr class="b">
<td>Refactoring support</td>
<td>IDE can find all usages</td></tr>
<tr class="a">
<td>Documentation</td>
<td>Types are self-documenting</td></tr></tbody>
</table>
<hr /></section><section>
<h2>Building Use Cases</h2><section>
<h3>Basic Pattern: validate/handle</h3>
<p>The core pattern separates validation from business logic:</p>

<div class="verbatim">
<pre><code class="language-java">HexaApp app = HexaFun.dsl()
    .useCase(CREATE)
        .validate(this::validateInput)   // Returns Result&lt;I&gt;
        .handle(this::createTask)        // Runs only if validation passes
    .build();
</code></pre></div>
<p>The <code>validate</code> step returns <code>Result&lt;I&gt;</code>:</p>
<ul>

<li>On success: passes the validated input to <code>handle</code></li>
<li>On failure: short-circuits and returns the error</li>
</ul></section><section>
<h3>Handler-Only Pattern</h3>
<p>For use cases that don't need validation:</p>

<div class="verbatim">
<pre><code class="language-java">HexaApp app = HexaFun.dsl()
    .useCase(LIST)
        .handle(input -&gt; taskRepository.findAll())
    .build();
</code></pre></div></section><section>
<h3>Chained Validators</h3>
<p>Multiple validators execute in order, short-circuiting on first failure:</p>

<div class="verbatim">
<pre><code class="language-java">HexaApp app = HexaFun.dsl()
    .useCase(ADD)
        .validate(this::validateNotNull)     // First check
        .validate(this::validateAmountRange) // Only runs if first passes
        .validate(this::validatePermissions) // Only runs if both pass
        .handle(this::addAmount)
    .build();
</code></pre></div>
<p>This is equivalent to composing validators with <code>flatMap</code>, but more readable.</p><hr /></section></section><section>
<h2>Implicit Closure</h2>
<p>The DSL uses implicit closure - each <code>useCase()</code> call automatically commits the previous one:</p>

<div class="verbatim">
<pre><code class="language-java">// No .and() needed between use cases
HexaApp app = HexaFun.dsl()
    .useCase(CREATE)
        .validate(this::validateCreate)
        .handle(this::createTask)
    .useCase(UPDATE)                     // Previous use case auto-committed
        .validate(this::validateUpdate)
        .handle(this::updateTask)
    .useCase(DELETE)                     // Previous use case auto-committed
        .handle(this::deleteTask)
    .build();                            // Final use case committed here
</code></pre></div>
<p>This reduces visual noise and makes the DSL more natural to read.</p><hr /></section><section>
<h2>Port Registry</h2>
<p>The DSL supports registering output ports (repositories, services, etc.) by type for dependency injection:</p>

<div class="verbatim">
<pre><code class="language-java">HexaApp app = HexaFun.dsl()
    .withPort(TaskRepository.class, new InMemoryTaskRepository())
    .withPort(EmailService.class, new SmtpEmailService())
    .useCase(CREATE)
        .validate(this::validateInput)
        .handle(this::createTask)
    .build();
</code></pre></div><section>
<h3>Retrieving Ports</h3>
<p>Retrieve ports by their type with compile-time safety:</p>

<div class="verbatim">
<pre><code class="language-java">// Type-safe retrieval
TaskRepository repo = app.port(TaskRepository.class);

// Check if a port is registered
if (app.hasPort(EmailService.class)) {
    EmailService email = app.port(EmailService.class);
}

// List all registered port types
Set&lt;Class&lt;?&gt;&gt; portTypes = app.registeredPorts();
</code></pre></div></section><section>
<h3>Direct Registration</h3>
<p>You can also register ports directly on a HexaApp:</p>

<div class="verbatim">
<pre><code class="language-java">HexaApp app = HexaApp.create();
app.port(TaskRepository.class, new InMemoryTaskRepository())
   .port(EmailService.class, new SmtpEmailService());
</code></pre></div></section><section>
<h3>Benefits</h3>
<table class="table table-striped">
<thead>
<tr class="a">
<th>Benefit</th>
<th>Description</th></tr></thead><tbody>
<tr class="b">
<td>Type safety</td>
<td>Compile-time checking prevents wrong types</td></tr>
<tr class="a">
<td>Testability</td>
<td>Easy to swap implementations for tests</td></tr>
<tr class="b">
<td>Decoupling</td>
<td>Use cases depend on interfaces, not implementations</td></tr>
<tr class="a">
<td>Discoverability</td>
<td><code>registeredPorts()</code> shows what's available</td></tr></tbody>
</table>
<hr /></section></section><section>
<h2>Invoking Use Cases</h2>
<p>Invoke use cases using their type-safe keys:</p>

<div class="verbatim">
<pre><code class="language-java">// Type-checked at compile time
Result&lt;Task&gt; result = app.invoke(CREATE, new CreateInput(&quot;My Task&quot;));

// This won't compile - wrong input type:
// app.invoke(CREATE, &quot;wrong type&quot;);  // Compile error!

// This won't compile - wrong return type:
// String result = app.invoke(CREATE, input);  // Compile error!
</code></pre></div><hr /></section><section>
<h2>Testing Use Cases</h2>
<p>The testing DSL integrates with type-safe keys:</p>

<div class="verbatim">
<pre><code class="language-java">// Test successful execution
app.test(CREATE)
   .with(new CreateInput(&quot;Test Task&quot;))
   .expectOk(task -&gt; {
       assertEquals(&quot;Test Task&quot;, task.getName());
       assertFalse(task.isCompleted());
   });

// Test validation failure
app.test(CREATE)
   .with(new CreateInput(&quot;&quot;))  // Empty name
   .expectFailure(error -&gt; {
       assertEquals(&quot;Name cannot be empty&quot;, error);
   });

// Test with transformation
app.test(CREATE)
   .with(new CreateInput(&quot;Test&quot;))
   .map(Result::get)
   .map(Task::getName)
   .expectOk(name -&gt; assertEquals(&quot;Test&quot;, name));
</code></pre></div><hr /></section><section>
<h2>Complete Example</h2>
<p>Here's a complete example showing all DSL features:</p>

<div class="verbatim">
<pre><code class="language-java">// 1. Define type-safe keys
public interface CounterUseCases {
    UseCaseKey&lt;IncrementInput, Result&lt;Counter&gt;&gt; INCREMENT =
        UseCaseKey.of(&quot;increment&quot;);
    UseCaseKey&lt;AddInput, Result&lt;Counter&gt;&gt; ADD =
        UseCaseKey.of(&quot;add&quot;);
}

// 2. Define validators
public class CounterValidators {
    public static Result&lt;IncrementInput&gt; validateIncrement(IncrementInput input) {
        if (input.counter() == null) {
            return Result.fail(&quot;Counter cannot be null&quot;);
        }
        return Result.ok(input);
    }

    public static Result&lt;AddInput&gt; validateCounter(AddInput input) {
        if (input.counter() == null) {
            return Result.fail(&quot;Counter cannot be null&quot;);
        }
        return Result.ok(input);
    }

    public static Result&lt;AddInput&gt; validateAmount(AddInput input) {
        if (input.amount() &lt; -100 || input.amount() &gt; 100) {
            return Result.fail(&quot;Amount must be between -100 and 100&quot;);
        }
        return Result.ok(input);
    }
}

// 3. Build the app
public class CounterApp {
    private final HexaApp app;

    public CounterApp() {
        this.app = HexaFun.dsl()
            .useCase(INCREMENT)
                .validate(CounterValidators::validateIncrement)
                .handle(input -&gt; Result.ok(input.counter().increment()))
            .useCase(ADD)
                .validate(CounterValidators::validateCounter)
                .validate(CounterValidators::validateAmount)
                .handle(input -&gt; Result.ok(input.counter().add(input.amount())))
            .build();
    }

    public Result&lt;Counter&gt; increment(Counter counter) {
        return app.invoke(INCREMENT, new IncrementInput(counter));
    }

    public Result&lt;Counter&gt; add(Counter counter, int amount) {
        return app.invoke(ADD, new AddInput(counter, amount));
    }
}

// 4. Test
@Test
void shouldIncrementCounter() {
    app.test(INCREMENT)
       .with(new IncrementInput(Counter.zero()))
       .expectOk(counter -&gt; assertEquals(1, counter.value()));
}

@Test
void shouldFailOnNullCounter() {
    app.test(INCREMENT)
       .with(new IncrementInput(null))
       .expectFailure(error -&gt; assertEquals(&quot;Counter cannot be null&quot;, error));
}

@Test
void shouldChainValidatorsForAdd() {
    app.test(ADD)
       .with(new AddInput(Counter.zero(), 500))  // Amount out of range
       .expectFailure(error -&gt; assertEquals(&quot;Amount must be between -100 and 100&quot;, error));
}
</code></pre></div><hr /></section><section>
<h2>Migration from Old API</h2>
<p>If you're migrating from an older version of HexaFun:</p>
<table class="table table-striped">
<thead>
<tr class="a">
<th>Old API</th>
<th>New API</th></tr></thead><tbody>
<tr class="b">
<td><code>.useCase(&quot;name&quot;)</code></td>
<td><code>.useCase(KEY)</code> where <code>KEY = UseCaseKey.of(&quot;name&quot;)</code></td></tr>
<tr class="a">
<td><code>.from(validator)</code></td>
<td><code>.validate(validator)</code></td></tr>
<tr class="b">
<td><code>.to(handler)</code></td>
<td><code>.handle(handler)</code></td></tr>
<tr class="a">
<td><code>.and()</code></td>
<td><em>(not needed - implicit closure)</em></td></tr>
<tr class="b">
<td><code>app.invoke(&quot;name&quot;, input)</code></td>
<td><code>app.invoke(KEY, input)</code></td></tr>
<tr class="a">
<td><code>app.test(&quot;name&quot;)</code></td>
<td><code>app.test(KEY)</code></td></tr></tbody>
</table>

<p>The new API is clearer, more type-safe, and requires less boilerplate.</p></section></section>
        </main>
    </div>
    <hr/>
    <footer>
      <div class="container">
        <div class="row">
            <p>©      2025
</p>
        </div>
        <p id="poweredBy" class="pull-right"><a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
</p>
      </div>
    </footer>
<script>
  if(anchors) {
    anchors.add();
  }
</script>
  </body>
</html>
